<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Phaser - Making your first game, part 3</title>
    <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
    <script src="Tetromino.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
    var configuration = {
        'canvas_width_max' : 2048,
        'canvas_width' : 1000,
        'canvas_height_max' : 2048,
        'canvas_height' : 650,
        'scale_ratio' : 1,
        'aspect_ratio' : 1
    };

    configuration.canvas_width = window.screen.availWidth * window.devicePixelRatio;
    configuration.canvas_height = window.screen.availHeight * window.devicePixelRatio;
    configuration.aspect_ratio = configuration.canvas_width / configuration.canvas_height;
    if (configuration.aspect_ratio < 1) configuration.scale_ratio = configuration.canvas_height / configuration.canvas_height_max;
    else configuration.scale_ratio = configuration.canvas_width / configuration.canvas_width_max;

    var game = new Phaser.Game(configuration.canvas_width, configuration.canvas_height, Phaser.CANVAS, 'gamewindow', {preload: preload, create: create, update: update});
    //var game = new Phaser.Game(800, 600, Phaser.AUTO, '', {preload: preload, create: create, update: update});

    var landed;
    var landedSprites;


    var score = 0;
    var scoreText;

    var cubesize = 32 * configuration.scale_ratio;
    var OffsetX = 256;
    var OffsetY = 64;

    var tetromino = null;

    var cursors;

    var moveDownKey;
    var moveUpKey;
    var moveLeftKey;
    var moveRightKey;

    var gameOver = false;

    function preload() {

        //game.load.image('cube', 'blocks/RED_block_1.png');
        game.load.spritesheet('1', 'blocks/red_block_strip.png', 32, 32);
        game.load.spritesheet('2', 'blocks/green_block_strip.png', 32, 32);
        game.load.spritesheet('3', 'blocks/green_block_strip.png', 32, 32);
        game.load.spritesheet('4', 'blocks/yellow_block_strip.png', 32, 32);
        game.load.spritesheet('5', 'blocks/purple_block_strip.png', 32, 32);
        game.load.spritesheet('6', 'blocks/purple_block_strip.png', 32, 32);
        game.load.spritesheet('7', 'blocks/red_block_strip.png', 32, 32);

    }

    function create() {


        game.physics.startSystem(Phaser.Physics.ARCADE);
        createTetromino();
        tetromino.enableBody = true;
        game.input.mouse.capture = true;

        var graphics = game.add.graphics(0, 0);

        // set a fill and line style
        graphics.beginFill(0xFF3300, 0);
        graphics.lineStyle(3, 0xffd900, 1);

        graphics.drawRect(OffsetX, OffsetY, cubesize * 10, cubesize * 16);


        window.graphics = graphics;

        landed = new Array(16);
        for (var i = 0; i < 16; i++) {
            landed[i] = new Array(10);
        }
        landedSprites = new Array(16);
        for (var i = 0; i < 16; i++) {
            landedSprites[i] = new Array(10);
        }

        for (i = 0; i < 16; i++) {
            for (var j = 0; j < 10; j++)
                landed[i][j] = 0;
        }


        game.time.events.loop(Phaser.Timer.SECOND * 1, progressTetromino, this);

        cursors = game.input.keyboard.createCursorKeys();
        moveLeftKey = game.input.keyboard.addKey(Phaser.Keyboard.LEFT);
        moveRightKey = game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);
        moveDownKey = game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
        moveUpKey = game.input.keyboard.addKey(Phaser.Keyboard.UP);

        drawBoardState();

        scoreText = game.add.text(16, 16, 'score: 0', {fontSize: '32px', fill: '#fff'});

    }

    function update() {


        for (var i = 0; i < tetromino.squares.length; i++) {
            tetromino.squares[i].inputEnabled = true;
            tetromino.squares[i].events.onInputUp.add(rotate, this);
        }

        if(gameOver){
            graphics.beginFill(0xFF3300, 1);
            graphics.lineStyle(3, 0xffd900, 1);
            graphics.drawRect(OffsetX, OffsetY, cubesize * 10, cubesize * 16);

        }
        else {

            game.input.onDown.add(checkMoveInput, this);
            //cursors.up.isDown.add(progressTetromino,this);
            if (moveLeftKey.justUp) {
                var potentialTopLeft = new Phaser.Point(tetromino.topLeft.x, tetromino.topLeft.y);
                potentialTopLeft.x--;
                var invalid = checkValidMovement(potentialTopLeft);


                if (!invalid)
                    tetromino.moveTetromino('left');
            }
            else if (moveRightKey.justUp) {

                var potentialTopLeft = new Phaser.Point(tetromino.topLeft.x, tetromino.topLeft.y);
                potentialTopLeft.x++;

                var invalid = checkValidMovement(potentialTopLeft);


                if (!invalid)
                    tetromino.moveTetromino('right');
            }
            else if (moveDownKey.justUp) {
                progressTetromino();
            }
            else if (moveUpKey.justUp) {
                rotate();
            }
        }

    }

    function checkMoveInput(){

        if(game.input.x > tetromino.squares[1].x + 32){
            var potentialTopLeft = new Phaser.Point(tetromino.topLeft.x, tetromino.topLeft.y);
            potentialTopLeft.x++;

            var invalid = checkValidMovement(potentialTopLeft);


            if (!invalid)
                tetromino.moveTetromino('right');
        }
        else if(game.input.x < tetromino.squares[1].x - 32){
            var potentialTopLeft = new Phaser.Point(tetromino.topLeft.x, tetromino.topLeft.y);
            potentialTopLeft.x--;
            var invalid = checkValidMovement(potentialTopLeft);


            if (!invalid)
                tetromino.moveTetromino('left');
        }
        else if(game.input.y > tetromino.squares[1].y + 32){
            progressTetromino();
        }



    }

    function checkValidMovement(potentialTopLeft) {

        var invalid = false;
        for (var row = 0; row < tetromino.shape.length; row++) {
            for (var col = 0; col < tetromino.shape[row].length; col++) {
                if (tetromino.shape[row][col] != 0) {
                    if (col + potentialTopLeft.x < 0) {
                        invalid = true;
                    }
                    if (col + potentialTopLeft.x >= landed[0].length) {
                        invalid = true;
                    }
                    if (row + potentialTopLeft.y >= 0 && col + potentialTopLeft.x >= 0)
                        if (landed[row + potentialTopLeft.y][col + potentialTopLeft.x] != 0) {
                            invalid = true;
                        }
                }
            }
        }
        return invalid;
    }
    function progressTetromino() {

        if (tetromino != null) {
            /*if (tetromino.topLeft.y < 0) {
                tetromino.moveTetromino('down');
            }
            else {*/
                var land = false;
                var potentialTopLeft = new Phaser.Point(tetromino.topLeft.x, tetromino.topLeft.y);
                potentialTopLeft.y++;
                for (var row = 0; row < tetromino.shape.length; row++) {
                    for (var col = 0; col < tetromino.shape[row].length; col++) {
                        if (tetromino.shape[row][col] != 0) {
                            if (row + potentialTopLeft.y >= 0 && col + potentialTopLeft.x >= 0) {
                                if ((row + potentialTopLeft.y >= landed.length)) {
                                    land = true;
                                }
                                else if ((landed[row + potentialTopLeft.y][col + potentialTopLeft.x] != 0)) {
                                    land = true;
                                }
                            }
                        }
                    }
                }

                if (!land) {
                    tetromino.moveTetromino('down');
                }

                if (land) {
                    for (var row = 0; row < tetromino.shape.length; row++) {
                        for (var col = 0; col < tetromino.shape[row].length; col++) {
                            if (tetromino.shape[row][col] != 0) {
                                if(row + potentialTopLeft.y <= 0) {
                                    gameOver = true;
                                    return;
                                }
                                landed[row + tetromino.topLeft.y][col + tetromino.topLeft.x] = tetromino.type;
                            }
                        }
                    }


                    tetromino.squares[0].destroy();
                    tetromino.squares[1].destroy();
                    tetromino.squares[2].destroy();
                    tetromino.squares[3].destroy();
                    tetromino = null;
                    createTetromino();

                    drawBoardState();
                    checkClearLines();

                    drawBoardState();

                }

            //}
        }
    }


    function checkClearLines() {
        var cleared = false;
        for (var row = 0; row < landed.length; row++) {
            var allTaken = true;
            for (var col = 0; col < landed[row].length; col++) {
                if (landed[row][col] == 0)
                    allTaken = false;
            }
            if (allTaken) {
                for (var i = row; i >= 0; i--) {
                    if (i != 0) //if i-1 row doesn't have all 0
                        landed.swap(i, i - 1);
                    else {
                        cleared = true;
                        for (var col = 0; col < landed[i].length; col++)
                            landed[i][col] = 0;
                    }
                }
                break;
            }

        }
        if (cleared) {
            checkClearLines();
            score += 100;
            scoreText.text = 'Score: ' + score;
        }
    }


    Array.prototype.swap = function (row1, row2) {

        /*for(var i = 0; i<landed[row1].length; i++) {
         var temp;
         temp = landed[row2][i];
         landed[row2][i] = landed[row1][i];
         landed[row1][i] = temp;
         }*/

        var temp = landed[row1];
        landed[row1] = landed[row2];
        landed[row2] = temp;
    };

    function createTetromino() {

        var topLeft = new Phaser.Point(5, -3);
        var type = game.rnd.integerInRange(1, 7);
        var rotation = game.rnd.integerInRange(0, 3);

        tetromino = new Tetromino(this.game, topLeft, rotation, type);

    }

    function rotate() {

        var invalid = false;
        var newRotation = tetromino.currentRotation;
        if (newRotation < 3) newRotation++;
        else newRotation = 0;
        var potentialShape = tetromino.shapeArray[newRotation];

        for (var row = 0; row < potentialShape.length; row++) {
            for (var col = 0; col < potentialShape[row].length; col++) {
                if (potentialShape[row][col] != 0) {
                    if (col + tetromino.topLeft.x < 0) {
                        invalid = true;
                    }
                    if (col + tetromino.topLeft.x >= landed[0].length) {
                        invalid = true;
                    }
                    if (row + tetromino.topLeft.y >= landed.length) {
                        invalid = true;
                    }

                    if (col + tetromino.topLeft.x >= 0 && row + tetromino.topLeft.y >= 0)
                    if (landed[row + tetromino.topLeft.y][col + tetromino.topLeft.x] != 0) {
                        invalid = true;
                    }
                }
            }
        }

        if (!invalid) {

            tetromino.squares[0].destroy();
            tetromino.squares[1].destroy();
            tetromino.squares[2].destroy();
            tetromino.squares[3].destroy();

            tetromino = new Tetromino(this.game, tetromino.topLeft, newRotation, tetromino.type);
        }


    }

    function drawBoardState() {
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 10; j++) {
                if (landed[i][j] != 0 && landedSprites[i][j] == null) {
                    landedSprites[i][j] = game.add.sprite(j * cubesize + OffsetX, i * cubesize + OffsetY, landed[i][j].toString());
                    landedSprites[i][j].scale.set(configuration.scale_ratio);
                }
                else if (landed[i][j] == 0 && landedSprites[i][j] != null) {
                    landedSprites[i][j].destroy();
                    landedSprites[i][j] = null;

                }
            }
        }
    }


</script>

</body>
</html>
